#!/usr/bin/python3


##################################################################################
#
# Description - This program pits the serial version of quicksort against the
#               parallel version of quicksort and reports the time it took to
#               sort a copy of a list containing a certain number of elements
#               for each algorithm.
#               References used for multiprocessing portion of program:
#               - https://docs.python.org/3/library/multiprocessing.html
#
# Author - Ted Li
#
##################################################################################


## IMPORTS SECTION ##

# import necessary libraries for generating lists of
#   strings of English alphabet characters.
import string
import numpy
# For declaring variables as non-modifiable
from typing import Final
# For measuring time elapsed for each sorting algorithm
import time
# For deep copying lists
import copy
# All multiprocessing imports are for parallelizing quicksort
import multiprocessing
# Personal implementation of serial quicksort
from serial_quicksort import serial_quicksort
# Personal implementation of parallel quicksort
from parallel_quicksort import parallel_quicksort

## END IMPORTS SECTION ##


## GLOBAL VARIABLES SECTION ##

# Length of each randomly generated string
LENGTH_OF_STRING: Final = 20
# Length of randomly generated string list
LENGTH_OF_STRING_LIST: Final = 2000000

## END GLOBAL VARIABLES SECTION ##


## BEGIN FUNCTIONS DECLARATIONS SECTION ##

# Main program comparing time took to execute serial version of
#    quicksort vs time took to execute parallel version of quicksort.
def main():

    print("\nInitializing list copies to be sorted (this may take some time)...")

    # randomly generated matrix of characters to be converted to a list of
    #     strings to be sorted
    char_matrix = numpy.random.choice(list(string.ascii_lowercase),
                                       size=(LENGTH_OF_STRING_LIST, LENGTH_OF_STRING))

    # Convert the matrix of characters generated by numpy into
    #   an actual list of strings
    string_list = [ "".join(row_of_chars) for row_of_chars in char_matrix ]
    # Made a copy of the list for sorting with parallel version of quicksort later
    string_list_copy = copy.deepcopy(string_list)

    # Let user know that we're generating the reference sorted list
    #   for validating correctness of each of my implementations of
    #   quicksort
    print("\nGenerating reference sorted list using Python's \"sorted\" "    \
            "built-in function for\n    validating correctness of serial " \
            "version and parallel version of quicksort... ", end="")

    # run reference sort algorithm (i.e. Python's "sorted" function) on
    #     a copy of the randomly generated list of strings to generate
    #     the reference sorted list
    reference_sorted_list = sorted(string_list)

    # Notify user we're done generating reference list.
    print("Done!")

    # Let user know that timing how long each of my personal implementations
    #     of quicksort runs starts now.
    print(f"\nTime to sort list of {LENGTH_OF_STRING_LIST} strings " \
           f"where each string is {LENGTH_OF_STRING} characters long...\n")

    # Run personal implementation of serial quicksort on
    #   on a copy of the same list and time how long the
    #   implementation takes to run
    start_sort_time = time.time()
    serial_quicksort(a_list=string_list)
    end_sort_time = time.time()

    # Report time took to run serial quicksort to user
    print(f"...using serial version of quicksort: " \
            f"{end_sort_time - start_sort_time:.6f} seconds.\n")

    # Run personal implementation of parallel quicksort on
    #   on a copy of the same list and time how long the
    #   implementation takes to run
    start_sort_time = time.time()
    # Create inter-process communications pipe for retrieving
    #     sorted list result from parent process that calls
    #     the parallel quicksort function.
    receive_sorted_list_socket, send_sorted_list_socket = \
                                multiprocessing.Pipe(duplex=False)
    # Create parent process for calling the parallel quicksort function;
    #     the "1" stands for "currently one process has been created for
    #     executing parallel quicksort."
    quicksort_parent_process = multiprocessing.Process(target=parallel_quicksort,                \
                                                            args=(string_list_copy,              \
                                                                  send_sorted_list_socket,       \
                                                                  1,                             \
                                                                  multiprocessing.cpu_count()))
    # Start the process
    quicksort_parent_process.start()
    # Fetch the sorted list from the process which called the
    #     parallel quicksort function; no need to close
    #     the pipe used to receive the list here because
    #     the "parallel_quicksort" function closes the
    #     pipe after it sends over the sorted list.
    string_list_copy = receive_sorted_list_socket.recv()
    # Wait until the parent process has finished transmitting the
    #     sorted list.
    quicksort_parent_process.join()
    end_sort_time = time.time()

    # Report time took to run parallel quicksort to user
    print(f"...using parallel version of quicksort\n" \
            f"    (parallelized over a target of "
            f"{multiprocessing.cpu_count()} processes): "
            f"{end_sort_time - start_sort_time:.6f} seconds.\n")

    # Report to user that it is validating the result of personal implementation
    #   of serial quicksort
    print("Validating result of serial version of quicksort...")

    numpy.testing.assert_array_equal(numpy.array(string_list),
                                     numpy.array(reference_sorted_list),
                                     err_msg="serial version of quicksort " \
                                     "did not produce a correctly sorted list.")

    # If an assertion error was not raised, print message of congratulations
    print("    Congratulations, expected and actual lists are equal!\n")

    # Report to user that it is validating the result of personal implementation
    #   of parallel quicksort
    print("Validating result of parallel version of quicksort...")

    numpy.testing.assert_array_equal(numpy.array(string_list_copy),
                                     numpy.array(reference_sorted_list),
                                     err_msg="parallel version of quicksort " \
                                     "did not produce a correctly sorted list.")

    # If an assertion error was not raised, print message of congratulations
    print("    Congratulations, expected and actual lists are equal!\n")


## END FUNCTION DECLARATIONS SECTION ##


if __name__ == "__main__":
    main()


